/*
    引数を１つだけ取り、値を返す配列の反復処理
 */
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

// 対象の配列の要素ひとつひとつを任意に加工した新しい配列を返す
console.log(arr.map((n) => n * 2));           // [2, 4, 6, 8, 10, 12, 14, 16, 18]
// 与えた条件に適合する要素だけを抽出した新しい配列を返す
console.log(arr.filter((n) => n % 3 === 0));  // [3, 6, 9]
// 与えた条件に適合した最初の要素を返す。見つからなかった場合は undefind を返す
console.log(arr.find((n) => n > 4));          // 5
// 与えた条件に適合した最初の要素のインデックスを返す。見つからなかった場 合は -1 を返す
console.log(arr.findIndex((n) => n > 4));     // 4
// 「与えた条件をすべての要素が満たすか」を真偽値で返す
console.log(arr.every((n) => n !== 0));       // true
// 「与えた条件を満たす要素がひとつでもあるか」を真偽値で返す
console.log(arr.some((n) => n >= 10));        // false

/*
    引数を２つ取り、値を返す配列の反復処理
 */
const arr2 = [1, 2, 3, 4, 5];

// reduce の動作について
//   1 回めの実行: m = 1、前回の実行がないので、結果は 1 がそのまま返る
//   2 回めの実行: m = 2、前回の実行結果により n = 1 、結果は 1  + 2 = 3  が返る
//   3 回めの実行: m = 3、前回の実行結果により n = 3、 結果は 3  + 3 = 6  が返る
//   4 回めの実行: m = 4、前回の実行結果により n = 6、 結果は 6  + 4 = 10 が返る
//   5 回めの実行: m = 5、前回の実行結果により n = 10、結果は 10 + 5 = 15 が返る
console.log(arr2.reduce((n, m) => n + m));        // 15

// 引数として既定の『比較関数』を渡す。比較関数のルールは以下の通り
//   i.   第 1 引数が第 2 引数より優先度が高い(前に来る)場合、-1 を返す
//   ii.  第 1 引数が第 2 引数より優先度が低い(後に来る)場合、1 を返す
//   iii. 第 1 引数と第 2 引数の優先度が同じ(ソートの必要がない)場合、0 を返す(※省略可)
console.log(arr2.sort((n, m) => n > m ? -1 : 1)); // [5, 4, 3, 2, 1]

/*
    値を返さない配列の反復処理
      - 使うなら forEach の方がマシ（Airbnb の JavaScript スタイルガイドでも使うなと言われている ）
      - 以下の２つを使う理由は主にその中で外部のミュータブルな変数を書き換えるといった副作用を
        起こすことだろうから、関数型プログラミングの文脈では往々にしてロジックの組み方をまちがえてるケースが多い
 */
const arr3 = [1, 2, 3, 4, 5, 6, 7, 8, 9];

arr3.forEach((n) => {
  if (n % 2 === 0) {
    console.log(`${n} is even`);
  }
});

for (let n of arr3) {
  if (n % 2 !== 0) {
    console.log(`${n} is odd`);
  }
}

/*
    関数型的な処理を行わない配列の反復処理
 */
const arr4 = [1, 2, 3, 4, 5];

// 『指定した値の要素がひとつでも含まれているか』を真偽値で返す Array のプロトタイプメソッド
console.log(arr4.includes(5)); // true
console.log(arr4.includes(9)); // false
